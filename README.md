# Завдання з використання Fork/Join Framework: Work Dealing та Work Stealing
### Мета:

Ознайомлення з підходами балансування задач в паралельних обчисленнях. Використання Fork/Join Framework для реалізації підходів до балансування задач, таких як Work Dealing і Work Stealing.

## Завдання 1: Знайти попарну суму усіх елементів одновимірного великого масиву.

Це завдання демонструє використання двох підходів для паралельного обчислення: **Work Stealing** за допомогою Fork/Join Framework та **Work Dealing** з використанням ThreadPool.

### Опис:

1. **Work Stealing**:
   - Масив розбивається на підмасиви, і кожен підмасив обробляється окремо за допомогою Fork/Join Framework.
   - Паралельно обчислюється сума пар сусідніх елементів масиву.

2. **Work Dealing**:
   - Масив поділяється на чотири частини, і кожна частина обробляється окремим потоком через пул потоків.
   - Кожен потік підраховує суму пар елементів у своєму сегменті масиву.

### Кроки виконання:

1. Користувач вводить розмір масиву, початкове та кінцеве значення для випадкових чисел.
2. Масив генерується випадковими числами в заданому діапазоні.
3. Обчислюється сума пар елементів масиву за допомогою двох підходів паралельних обчислень.
4. Результати виводяться разом з часом виконання кожного підходу.

- **Work Stealing**:
  - Час виконання: 1.617 мс
  - Результат: 2768
- **Work Dealing**:
  - Час виконання: 2.8267 мс
  - Результат: 3068

### Пояснення:
- **Work Stealing** працює швидше через можливість потоків "викрадати" задачі один у одного, що дає більшу ефективність при нерівномірному навантаженні.
- **Work Dealing** має певні обмеження, оскільки задачі рівномірно розподіляються між потоками, що може призводити до неефективного використання процесорних ресурсів.

### Висновки:
- **Work Stealing** виявився ефективнішим в даному випадку для підрахунку суми парних чисел у випадковому масиві.
- Для великих обсягів даних **Work Stealing** показує кращі результати.


## Завдання 2: Підрахунок Файлів з Певним Розширенням у Директорії

Це завдання використовує **Fork/Join Framework** для рекурсивного підрахунку файлів з певним розширенням у директорії та її підкаталогах.

### Опис:

1. Створюється рекурсивне завдання `FileCounterTask`, яке обходить директорії та підкаталоги.
2. Для кожної директорії створюється підзадача, яка асинхронно підраховує файли з вказаним розширенням.
3. Користувач може ввести шлях до директорії та бажане розширення файлів для пошуку.

### Кроки виконання:

1. Користувач вводить шлях до директорії, де потрібно здійснити пошук.
2. Користувач вказує розширення файлів для пошуку (за замовчуванням: `.pdf`).
3. Рекурсивно обробляються всі директорії та підкаталоги для підрахунку кількості файлів з вказаним розширенням.
4. Результат підрахунку та час виконання завдання виводяться в консоль.

## Чому було обрано Fork/Join Framework?

Для цієї задачі було обрано використання **Fork/Join Framework** через такі причини:

### 1. Паралельне виконання для підвищення ефективності:
  - Оскільки завдання передбачає обробку великої кількості файлів у різних підкаталогах, паралельне виконання завдання дозволяє значно зменшити час обробки.
  - **Fork/Join Framework** дозволяє ефективно виконувати рекурсивні задачі, де кожен каталог можна обробляти окремо в різних потоках, що зменшує час очікування і підвищує продуктивність.

### 2. Легкість реалізації:
  - Підхід за допомогою **Fork/Join Framework** дозволяє реалізувати обробку каталогів у вигляді рекурсивних задач, де кожна задача обробляє окремий каталог або підкаталог. Це спрощує код і робить його більш гнучким для подальших змін.
  - Використання пулу потоків через `ForkJoinPool` дозволяє автоматично управляти ресурсами і забезпечує належний баланс між потоками.

### 3. Розподіл навантаження:
  - За допомогою рекурсивного підходу з **Fork/Join** задачі автоматично розподіляються між потоками, що дозволяє ефективно використовувати багатоядерні процесори та скоротити час виконання при обробці великих директорій з багатьма файлами.

### Переваги та недоліки:

**Переваги**:
- Чітке розподілення роботи між потоками.
- Покращена продуктивність при обробці великих кількостей файлів у великій кількості підкаталогів.
- Легкість реалізації за допомогою **Fork/Join Framework**, що дозволяє уникнути ручного розподілу задач.

**Недоліки**:
- Якщо директорії містять невелику кількість файлів, підхід може не дати значного покращення продуктивності через накладні витрати на створення підзадач.
- Для дуже дрібних завдань **Fork/Join Framework** може бути занадто "важким" і не давати суттєвих переваг у часі.


## Результат:
![image](https://github.com/vitaliks01/-3-/blob/main/Screenshot_1.png)

